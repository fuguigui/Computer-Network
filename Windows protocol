#include "sysinclude.h"
#include <queue>
#include <vector>

extern void SendFRAMEPacket(unsigned char* pData, unsigned int len);

#define WINDOW_SIZE_STOP_WAIT 1
#define WINDOW_SIZE_BACK_N_FRAME 4

typedef enum{data,ack,nak} frame_kind;
typedef struct frame_head{
	frame_kind kind;
	unsigned int seq;
	unsigned int ack;
	unsigned char data[100];
	};
typedef struct frame{
	frame_head head;
	unsigned int size;
};

typedef struct Frame{
	frame* pframe;
	int size;
};

queue<Frame> SendList;
queue<Frame> WaitList;
vector<Frame> BackSendVec;
vector<Frame> ChoiceSendVec;
vector<Frame>::iterator it;
/*
* 停等协议测试函数
*/
int stud_slide_window_stop_and_wait(char *pBuffer, int bufferSize, UINT8 messageType)
{
	Frame tmpFrame;
	tmpFrame.pframe = new frame;
	tmpFrame.pframe = (frame*)pBuffer;
	tmpFrame.size = bufferSize;
	int ack = tmpFrame.pframe->head.ack;
	int seq = tmpFrame.pframe->head.seq;

	if(messageType == MSG_TYPE_SEND){
		//将帧加入发送缓存，并发送
		if(SendList.size() == WINDOW_SIZE_STOP_WAIT){
			//如果当前发送窗口满了，就加入等待发送队列，结束 
			WaitList.push(tmpFrame); 
		}
		else{
			//如果发送窗口没有满，就加入发送缓存，并发送
			SendList.push(tmpFrame);
			SendFRAMEPacket((unsigned char*)pBuffer,bufferSize);
		}
	}
	else if(messageType == MSG_TYPE_RECEIVE) {
		//收到确认帧，检查是否发送成功。 
		if(((frame*)pBuffer)->head.kind == ack){
			//发送成功，检查序号是否一致
		int headseq = SendList.front().pframe->head.seq;
		if(headseq == seq){
			//如果序列号相等,清除发送缓存
			SendList.pop();
			if(WaitList.size()>0){
				//如果等待发送队列非空，存入发送缓存，并发送
				Frame sendFrame = WaitList.front();
				WaitList.pop();
				unsigned char* sendP = (unsigned char*)sendFrame.pframe;
				SendList.push(sendFrame);
		        SendFRAMEPacket(sendP,sendFrame.size);
			}
		}
		}
		else{
			//发送失败，重新发送;
			Frame sendFrame = SendList.front();
			unsigned char* sendP = (unsigned char*)sendFrame.pframe;
		    SendFRAMEPacket(sendP,sendFrame.size);
		}
	}
	else if(messageType == MSG_TYPE_TIMEOUT){
		//如果超时，就重新发送 
		Frame sendFrame = SendList.front();
		unsigned char* sendP = (unsigned char*)sendFrame.pframe;
		SendFRAMEPacket(sendP,sendFrame.size);
	}
	return 0;
}


/*
* 回退n帧测试函数
*/
int stud_slide_window_back_n_frame(char *pBuffer, int bufferSize, UINT8 messageType)
{
Frame tmpFrame;
	tmpFrame.pframe = new frame;
	tmpFrame.pframe = (frame*)pBuffer;
	tmpFrame.size = bufferSize;
	int ack = tmpFrame.pframe->head.ack;
	int seq = tmpFrame.pframe->head.seq;

	if(messageType == MSG_TYPE_SEND){
		//将帧加入发送缓存，并发送
		if(BackSendVec.size() == WINDOW_SIZE_BACK_N_FRAME){
			//如果发送窗口已满，加入等待序列
			WaitList.push(tmpFrame); 
		}
		else{
			BackSendVec.push_back(tmpFrame);
			SendFRAMEPacket((unsigned char *)pBuffer,bufferSize);
		}
	}
	else if(messageType == MSG_TYPE_RECEIVE) {
		int tmpseq = BackSendVec[0].pframe->head.seq;
		if(((frame*)pBuffer)->head.kind == ack){
			//收到成功确认，验证序列号 
			if(tmpseq == seq){
				//如果序列号相等,减少发送缓存 
				it = BackSendVec.begin();
				BackSendVec.erase(BackSendVec.begin(),it + 1);
				while(WaitList.size()>0 && BackSendVec.size()< WINDOW_SIZE_BACK_N_FRAME){
					//发送等待队列中的帧
					Frame sendFrame = WaitList.front();
					WaitList.pop();
					unsigned char* sendP = (unsigned char*)sendFrame.pframe;
					BackSendVec.push_back(sendFrame);
		        	SendFRAMEPacket(sendP,sendFrame.size);
				}
			}
			else{
				//退回重发全部发送缓存中的帧
				for(int i = 0;i<BackSendVec.size();++i){
					Frame sendFrame =BackSendVec[i];
					unsigned char* sendP = (unsigned char*)sendFrame.pframe;
		        	SendFRAMEPacket(sendP,sendFrame.size);
				} 
			}
		}
		else{
			//发送失败，全部重新发送;
			for(int i = 0;i<BackSendVec.size();++i){
				Frame sendFrame =BackSendVec[i];
				unsigned char* sendP = (unsigned char*)sendFrame.pframe;
		        	SendFRAMEPacket(sendP,sendFrame.size);
			} 
		}
	}
	else if(messageType == MSG_TYPE_TIMEOUT){
		//如果超时，全部重新发送
		for(int i = 0;i<BackSendVec.size();++i){
			Frame sendFrame =BackSendVec[i];
			unsigned char* sendP = (unsigned char*)sendFrame.pframe;
			SendFRAMEPacket(sendP, sendFrame.size);
			} 
	}
	return 0;
}

/*
* 选择性重传测试函数
*/
int stud_slide_window_choice_frame_resend(char *pBuffer, int bufferSize, UINT8 messageType)
{
	Frame tmpFrame;
	tmpFrame.pframe = new frame;
	tmpFrame.pframe = (frame*)pBuffer;
	int ack = tmpFrame.pframe->head.ack;
	int seq = tmpFrame.pframe->head.seq;
	if(messageType == MSG_TYPE_SEND){
		if(BackSendVec.size() == WINDOW_SIZE_BACK_N_FRAME){
			//如果发送窗口已满，将帧加入等待缓存
			WaitList.push(tmpFrame); 
		}
		else{
			//加入发送缓存，并发送
			BackSendVec.push_back(tmpFrame);
			SendFRAMEPacket((unsigned char*)pBuffer,bufferSize);
		}
	}
	else if(messageType == MSG_TYPE_RECEIVE) {
		if(((frame*)pBuffer)->head.kind == ack){
			//收到成功确认，比对序列号，删除发送缓存中，序列号对应相等的帧
		for(it = BackSendVec.begin(); it != BackSendVec.end(); ++ it)
            {
                Frame receiveframe = *it;
                if(seq == ((receiveframe.pframe)->head.seq))
                {
                    BackSendVec.erase(BackSendVec.begin(), it + 1);
                    break;
                }
            }

			//等待队列不为空，则发送等待队列中的帧
			while(WaitList.size()>0 && BackSendVec.size()< WINDOW_SIZE_BACK_N_FRAME){
					Frame sendFrame = WaitList.front();
					WaitList.pop();
					unsigned char* sendP = (unsigned char*)sendFrame.pframe;
		        	SendFRAMEPacket(sendP,sendFrame.size);
		        	BackSendVec.push_back(sendFrame);
				}
			}
		}
		else{
			//发送失败，重新发送该帧;
			for(int i = 0;i<BackSendVec.size();++i){
				int tmpseq = BackSendVec[i].pframe->head.seq;
				if (tmpseq == seq) {
					Frame sendFrame = BackSendVec[i];
					unsigned char* sendP = (unsigned char*)sendFrame.pframe;
					SendFRAMEPacket(sendP, sendFrame.size);
					break;
				}
			} 
		}
	}
	else if(messageType == MSG_TYPE_TIMEOUT){
		//超时，重新发送该帧
		for (int i = 0; i<BackSendVec.size(); ++i) {
			int tmpseq = BackSendVec[i].pframe->head.seq;
			if (tmpseq == seq) {
				Frame sendFrame = BackSendVec[i];
				unsigned char* sendP = (unsigned char*)sendFrame.pframe;
				SendFRAMEPacket(sendP, sendFrame.size);
				break;
			}
		}
	}
	return 0;
}
